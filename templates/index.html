<html>
  <head>
    <title>Demo</title>
  </head>

  <body>
    <div id="app">
      <div class="flex flex-row flex-nowrap" :style="{ height: tsneHeight }">
        <div id="plot"></div>
        <div class="w-full h-full overflow-hidden px-1 ml-2 border">
          <div>selected users: [[ selectedUsers.length ]]</div>
          <div class="overflow-auto h-full">
            <ul>
              <li v-for="{ id } in sortedSelectedUsers" :key="id">[[ id ]]</li>
            </ul>
          </div>
        </div>
      </div>
      <div id="heatmap"></div>
    </div>
  </body>

  <!-- import Vue.js -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
  <!-- import d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://d3js.org/d3-color.v2.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
  <script>
    const plot = {{ plot|tojson|safe }};

    var app = new Vue({
      el: "#app",
      delimiters: ["[[", "]]"],
      data: {
        selectedUsers: [],
        tsneWidth: 1100,
        tsneHeight: 700,
        heatmapUnitHeight: 50,
      },
      watch: {
        selectedUsers() {
          this.drawHeatmap();
        },
      },
      computed: {
        sortedSelectedUsers() {
          return this.selectedUsers.sort((a, b) =>
            a.id.toUpperCase() <= b.id.toUpperCase() ? -1 : 1
          );
        },
        heatmapWidth() {
          return this.heatmapUnitHeight * 24;
        },
      },
      mounted() {
        this.drawTSNE();
      },
      methods: {
        drawTSNE() {
          const vue = this;
          const data = plot;
          const coord_x = data.map((d) => d.coord[0]);
          const coord_y = data.map((d) => d.coord[1]);
          const [minX, maxX] = [Math.min(...coord_x), Math.max(...coord_x)];
          const [minY, maxY] = [Math.min(...coord_y), Math.max(...coord_y)];
          const margin = { top: 20, right: 20, bottom: 20, left: 20 };
          const fullWidth = this.tsneWidth;
          const width = fullWidth - margin.left - margin.right;
          const fullHeight = this.tsneHeight;
          const height = fullHeight - margin.top - margin.bottom;

          const x = d3.scaleLinear().domain([minX, maxX]).range([0, width]);
          const y = d3.scaleLinear().domain([minY, maxY]).range([height, 0]);
          const color = d3
            .scaleOrdinal()
            .domain(["midnight", "morning", "afternoon", "evening"])
            .range(["#003f5c", "#7a5195", "#ef5675", "#ffa600"]);

          const svg = d3
            .select("#plot")
            .append("svg")
            .attr("width", fullWidth)
            .attr("height", fullHeight)
            .style("border", "1px solid #000")
            .append("g")
            .attr(
              "transform",
              "translate(" + margin.left + "," + margin.top + ")"
            );

          // Add dots
          const dots = svg
            .append("g")
            .selectAll("dot")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", (d) => x(d.coord[0]))
            .attr("cy", (d) => y(d.coord[1]))
            .attr("r", 7)
            .style("fill", (d) => color(d.label))
            .style("opacity", 0.5);

          // Add brushing
          d3.select("#plot > svg").call(
            d3
              .brush()
              .extent([
                [0, 0],
                [fullWidth, fullHeight],
              ])
              .on("brush", updateChart)
          );

          // Function that is triggered when brushing is performed
          function updateChart() {
            extent = d3.event.selection;
            const selected = dots.filter((d) =>
              isBrushed(extent, x(d.coord[0]), y(d.coord[1]))
            );
            dots.classed("selected", false);
            selected.classed("selected", true);
            vue.selectedUsers = selected.nodes().map((node) => node.__data__);
          }

          // A function that return TRUE or FALSE according if a dot is in the selection or not
          function isBrushed(brush_coords, cx, cy) {
            const x0 = brush_coords[0][0] - margin.left,
              x1 = brush_coords[1][0] - margin.left,
              y0 = brush_coords[0][1] - margin.top,
              y1 = brush_coords[1][1] - margin.top;
            return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1; // This return TRUE or FALSE depending on if the points is in the selected area
          }

          // Add legend
          const legendX = fullWidth - 120,
            legendY = 30;
          const labels = ["midnight", "morning", "afternoon", "evening"];
          labels.forEach((l, idx) => {
            svg
              .append("circle")
              .attr("cx", legendX)
              .attr("cy", 10 + legendY * idx)
              .attr("r", 7)
              .style("fill", color(l));
            svg
              .append("text")
              .attr("x", legendX + 20)
              .attr("y", 10 + legendY * idx)
              .text(l)
              .style("fill", "black")
              .style("font-size", "15px")
              .attr("alignment-baseline", "middle");
          });
        },
        drawHeatmap() {
          d3.selectAll("#heatmap > *").remove();

          const vue = this;
          const data = this.selectedUsers
            .map((u) =>
              u.activities.map((a, i) => ({
                row: u.id,
                col: i,
                value: a,
              }))
            )
            .reduce((a, b) => [...a, ...b], []);
          const values = data.map((d) => d.value);
          const margin = { top: 20, right: 20, bottom: 20, left: 100 };
          const width = this.heatmapWidth;
          const fullWidth = width + margin.left + margin.right;
          const height = this.heatmapUnitHeight * this.selectedUsers.length;
          const fullHeight = height + margin.top + margin.bottom;

          const svg = d3
            .select("#heatmap")
            .append("svg")
            .attr("width", fullWidth)
            .attr("height", fullHeight)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          const x = d3
            .scaleBand()
            .range([0, width])
            .domain(data.map((d) => d.col))
            .padding(0.05);
          svg
            .append("g")
            .style("font-size", 15)
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x).tickSize(0))
            .select(".domain")
            .remove();

          const y = d3
            .scaleBand()
            .range([height, 0])
            .domain(data.map((d) => d.row))
            .padding(0);
          svg
            .append("g")
            .style("font-size", 15)
            .call(d3.axisLeft(y).tickSize(0))
            .select(".domain")
            .remove();

          const color = d3
            .scaleSequential(d3.interpolatePurples)
            .domain([Math.min(...values), Math.max(...values)]);

          svg
            .selectAll()
            .data(data, (d) => `${d.row},${d.col}`)
            .enter()
            .append("rect")
            .attr("x", (d) => x(d.col))
            .attr("y", (d) => y(d.row))
            .attr("rx", 4)
            .attr("ry", 4)
            .attr("width", x.bandwidth())
            .attr("height", x.bandwidth())
            .style("fill", (d) => color(d.value))
            .style("stroke-width", 4)
            .style("stroke", "none")
            .style("opacity", 0.8);
        },
      },
    });
  </script>

  <style>
    .selected {
      opacity: 1 !important;
      stroke: black;
      stroke-width: 1px;
    }
    .flex {
      display: flex;
    }
    .flex-row {
      flex-direction: row;
    }
    .flex-nowrap {
      flex-wrap: nowrap;
    }
    .w-full {
      width: 100%;
    }
    .h-full {
      height: 100%;
    }
    .overflow-hidden {
      overflow: hidden;
    }
    .overflow-auto {
      overflow: auto;
    }
    .px-1 {
      padding: 0 4px;
    }
    .ml-2 {
      margin-left: 8px;
    }
    .border {
      border: 1px solid #c3c3c3;
    }
  </style>
</html>
